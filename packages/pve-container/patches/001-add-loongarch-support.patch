From 6c3157c3324c5e47cb0a8c3df0aaa59b753a2f2f Mon Sep 17 00:00:00 2001
From: jiangcuo <jiangcuo@bingsin.com>
Date: Thu, 5 Dec 2024 11:31:29 +0800
Subject: [PATCH] Add loongarch support

---
 src/PVE/LXC/Config.pm       |  2 +-
 src/PVE/LXC/Setup.pm        | 11 ----------
 src/PVE/LXC/Setup/Plugin.pm | 44 ++++++++++++++++++++++++++++++++++++-
 src/PVE/LXC/Tools.pm        |  1 +
 4 files changed, 45 insertions(+), 13 deletions(-)

diff --git a/src/PVE/LXC/Config.pm b/src/PVE/LXC/Config.pm
index 5cc37f7..0452d4a 100644
--- a/src/PVE/LXC/Config.pm
+++ b/src/PVE/LXC/Config.pm
@@ -473,7 +473,7 @@ my $confdesc = {
     arch => {
 	optional => 1,
 	type => 'string',
-	enum => ['amd64', 'i386', 'arm64', 'armhf', 'riscv32', 'riscv64'],
+	enum => ['amd64', 'i386', 'arm64', 'armhf', 'riscv32', 'riscv64', 'loongarch64'],
 	description => "OS architecture type.",
 	default => 'amd64',
     },
diff --git a/src/PVE/LXC/Setup.pm b/src/PVE/LXC/Setup.pm
index dc58990..78272be 100644
--- a/src/PVE/LXC/Setup.pm
+++ b/src/PVE/LXC/Setup.pm
@@ -141,17 +141,6 @@ sub new {
     if (!defined($conf->{arch})) {
 	my $arch = eval { $self->protected_call(sub { $plugin->detect_architecture() }) };
 
-	if (my $err = $@) {
-	    warn "Architecture detection failed: $err" if $err;
-	}
-
-	if (!defined($arch)) {
-	    $arch = 'amd64';
-	    print "Falling back to $arch.\nUse `pct set VMID --arch ARCH` to change.\n";
-	} else {
-	    print "Detected container architecture: $arch\n";
-	}
-
 	$conf->{arch} = $arch;
     }
 
diff --git a/src/PVE/LXC/Setup/Plugin.pm b/src/PVE/LXC/Setup/Plugin.pm
index b9d9c2d..f413d91 100644
--- a/src/PVE/LXC/Setup/Plugin.pm
+++ b/src/PVE/LXC/Setup/Plugin.pm
@@ -6,6 +6,7 @@ use strict;
 use warnings;
 
 use Carp;
+use PVE::Tools qw(get_host_arch);
 
 sub new {
     my ($class, $conf, $rootdir, $os_release) = @_;
@@ -64,7 +65,48 @@ sub ssh_host_key_types_to_generate {
 
 sub detect_architecture {
     my ($self) = @_;
-    croak "implement me in sub-class\n";
+    # see https://en.wikipedia.org/wiki/Executable_and_Linkable_Format
+    my $supported_elf_machine = {
+	0x03 => 'i386',
+	0x3e => 'amd64',
+	0x28 => 'armhf',
+	0xb7 => 'arm64',
+    0xf3 => 'riscv',
+	0x2 => 'loongarch64',
+    };
+
+    my $elf_fn = '/bin/sh'; # '/bin/sh' is POSIX mandatory
+    my $detect_arch = sub {
+	# chroot avoids a problem where we check the binary of the host system
+	# if $elf_fn is an absolut symlink (e.g. $rootdir/bin/sh -> /bin/bash)
+	open(my $fh, "<", $elf_fn) or die "open '$elf_fn' failed: $!\n";
+	binmode($fh);
+
+	my $length = read($fh, my $data, 20) or die "read failed: $!\n";
+
+	# 4 bytes ELF magic number and 1 byte ELF class, padding, machine
+	my ($magic, $class, undef, $machine) = unpack("A4CA12n", $data);
+
+	die "'$elf_fn' does not resolve to an ELF!\n"
+	    if (!defined($class) || !defined($magic) || $magic ne "\177ELF");
+
+	my $arch = $supported_elf_machine->{$machine};
+	die "'$elf_fn' has unknown ELF machine '$machine'!\n"
+	    if !defined($arch);
+
+	return $arch;
+    };
+
+    my $arch = eval { PVE::Tools::run_fork_with_timeout(5, $detect_arch) };
+    if (my $err = $@) {
+	    $arch = get_host_arch();
+	    print "Architecture detection failed: $err\nFalling back to $arch.\n" .
+	    "Use `pct set VMID --arch ARCH` to change.\n";
+    } else {
+	    print "Detected container architecture: $arch\n";
+    }
+
+    return $arch;
 }
 
 # hooks
diff --git a/src/PVE/LXC/Tools.pm b/src/PVE/LXC/Tools.pm
index 3380c62..a9aa942 100644
--- a/src/PVE/LXC/Tools.pm
+++ b/src/PVE/LXC/Tools.pm
@@ -179,6 +179,7 @@ sub detect_elf_architecture {
 	0x28 => 'armhf',
 	0xb7 => 'arm64',
 	0xf3 => 'riscv',
+	0x2 => 'loongarch64',
     };
 
     my $detect_arch = sub {
